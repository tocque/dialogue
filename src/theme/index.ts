import { HighlightStyle, Tag, tags as t } from "@codemirror/highlight";
import light_plus from "./light_plus.json";

const tagMap: Record<string, Tag> = {
    // "meta.embedded"
    // "source.groovy.embedded"
    // "emphasis"
    // "strong"
    // "meta.diff.header"
    "comment": t.comment,
    // "constant.language"
    "constant.numeric": t.number,
    // "variable.other.enummember"
    // "keyword.operator.plus.exponent"
    // "keyword.operator.minus.exponent"
    // "constant.regexp"
    // "entity.name.tag"
    // "entity.name.selector"
    // "entity.other.attribute-name"
    // "entity.other.attribute-name.class.css"
    // "entity.other.attribute-name.class.mixin.css"
    // "entity.other.attribute-name.id.css"
    // "entity.other.attribute-name.parent-selector.css"
    // "entity.other.attribute-name.pseudo-class.css"
    // "entity.other.attribute-name.pseudo-element.css"
    // "source.css.less entity.other.attribute-name.id"
    // "entity.other.attribute-name.attribute.scss"
    // "entity.other.attribute-name.scss"
    // "invalid"
    // "markup.underline"
    // "markup.bold"
    "markup.heading": t.heading,
    // "markup.italic"
    // "markup.inserted"
    // "markup.deleted"
    // "markup.changed"
    // "punctuation.definition.quote.begin.markdown"
    // "punctuation.definition.list.begin.markdown"
    // "markup.inline.raw"
    "punctuation.definition.tag": t.angleBracket,
    // "meta.preprocessor"
    // "entity.name.function.preprocessor"
    // "meta.preprocessor.string"
    // "meta.preprocessor.numeric"
    // "meta.structure.dictionary.key.python"
    // "storage"
    // "storage.type"
    // "storage.modifier"
    // "keyword.operator.noexcept"
    "string": t.string,
    // "meta.embedded.assembly"
    // "string.comment.buffered.block.pug"
    // "string.quoted.pug"
    // "string.interpolated.pug"
    // "string.unquoted.plain.in.yaml"
    // "string.unquoted.plain.out.yaml"
    // "string.unquoted.block.yaml"
    // "string.quoted.single.yaml"
    // "string.quoted.double.xml"
    // "string.quoted.single.xml"
    // "string.unquoted.cdata.xml"
    // "string.quoted.double.html"
    // "string.quoted.single.html"
    // "string.unquoted.html"
    // "string.quoted.single.handlebars"
    // "string.quoted.double.handlebars"
    "string.regexp": t.regexp,
    // "punctuation.definition.template-expression.begin"
    // "punctuation.definition.template-expression.end"
    // "punctuation.section.embedded"
    // "meta.template.expression"
    // "support.constant.property-value"
    // "support.constant.font-name"
    // "support.constant.media-type"
    // "support.constant.media"
    // "constant.other.color.rgb-value"
    // "constant.other.rgb-value"
    // "support.constant.color"
    // "support.type.vendored.property-name"
    // "support.type.property-name"
    // "variable.css"
    // "variable.scss"
    // "variable.other.less"
    // "source.coffee.embedded"
    // "support.type.property-name.json"
    "keyword": t.keyword,
    "keyword.control": t.controlKeyword,
    "keyword.operator": t.operatorKeyword,
    // "keyword.operator.new"
    // "keyword.operator.expression"
    // "keyword.operator.cast"
    // "keyword.operator.sizeof"
    // "keyword.operator.alignof"
    // "keyword.operator.typeid"
    // "keyword.operator.alignas"
    // "keyword.operator.instanceof"
    // "keyword.operator.logical.python"
    // "keyword.operator.wordlike"
    // "keyword.other.unit"
    // "punctuation.section.embedded.begin.php"
    // "punctuation.section.embedded.end.php"
    // "support.function.git-rebase"
    // "constant.sha.git-rebase"
    // "storage.modifier.import.java"
    // "variable.language.wildcard.java"
    // "storage.modifier.package.java"
    // "variable.language"
    // "entity.name.function"
    // "support.function"
    // "support.constant.handlebars"
    // "source.powershell variable.other.member"
    // "entity.name.operator.custom-literal"
    // "meta.return-type"
    // "support.class"
    // "support.type"
    // "entity.name.type"
    // "entity.name.namespace"
    // "entity.other.attribute"
    // "entity.name.scope-resolution"
    // "entity.name.class"
    // "storage.type.numeric.go"
    // "storage.type.byte.go"
    // "storage.type.boolean.go"
    // "storage.type.string.go"
    // "storage.type.uintptr.go"
    // "storage.type.error.go"
    // "storage.type.rune.go"
    // "storage.type.cs"
    // "storage.type.generic.cs"
    // "storage.type.modifier.cs"
    // "storage.type.variable.cs"
    // "storage.type.annotation.java"
    // "storage.type.generic.java"
    // "storage.type.java"
    // "storage.type.object.array.java"
    // "storage.type.primitive.array.java"
    // "storage.type.primitive.java"
    // "storage.type.token.java"
    // "storage.type.groovy"
    // "storage.type.annotation.groovy"
    // "storage.type.parameters.groovy"
    // "storage.type.generic.groovy"
    // "storage.type.object.array.groovy"
    // "storage.type.primitive.array.groovy"
    // "storage.type.primitive.groovy"
    // "meta.type.cast.expr"
    // "meta.type.new.expr"
    // "support.constant.math"
    // "support.constant.dom"
    // "support.constant.json"
    // "entity.other.inherited-class"
    // "source.cpp keyword.operator.new"
    // "source.cpp keyword.operator.delete"
    // "keyword.other.using"
    // "keyword.other.operator"
    // "entity.name.operator"
    "variable": t.variableName,
    // "meta.definition.variable.name"
    // "support.variable"
    // "entity.name.variable"
    // "variable.other.constant"
    // "meta.object-literal.key"
    // "punctuation.definition.group.regexp"
    // "punctuation.definition.group.assertion.regexp"
    // "punctuation.definition.character-class.regexp"
    // "punctuation.character.set.begin.regexp"
    // "punctuation.character.set.end.regexp"
    // "keyword.operator.negation.regexp"
    // "support.other.parenthesis.regexp"
    // "constant.character.character-class.regexp"
    // "constant.other.character-class.set.regexp"
    // "constant.other.character-class.regexp"
    // "constant.character.set.regexp"
    // "keyword.operator.quantifier.regexp"
    // "keyword.operator.or.regexp"
    // "keyword.control.anchor.regexp"
    // "constant.character"
    // "constant.character.escape"
    // "entity.name.label"
}

export const lightplus = HighlightStyle.define(
    light_plus.rules
        .filter(({ token }) => token in tagMap)
        .map(({ token, ...rest }) => {
            const style: Record<string, string> = {};
            if (rest.foreground) style.color = rest.foreground;
            if (rest.fontStyle) style.fontStyle = rest.fontStyle;
            return { tag: tagMap[token], ...style };
        })
);
